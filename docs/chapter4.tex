\section {Алгоритм сравнения цепочек}
 Для принятия решения о нахождении похожих цепочек вызовов в логах необходимо выбрать способ. В этой главе будет описан выбранный алгоритм, позволяющий находить не только идентичные цепочки, но и до определённой степени видоизменённые вставленными в них дополнительными вызовами, например:

kernel32.OpenFile -> kernel32.SetFilePointer -> kernel32.Sleep -> kernel32.WriteFile

vs

kernel32.CreateFile -> kernel32.SetFilePointer -> --  ->   kernel32.WriteFile

Будут совмещены как похожие, если в матрице весов указать достаточное значение близости OpenFile к CreateFile.
В данном случае пропуск  вызова (символа) при сравнении двух последовательностей будет обозначаться как ``--'', и аналогичен совмещению (kernel32.Sleep, -- ) при выравнивании.
\subsection {Приведение данных к удобной для обработки форме}
Собранные текстовые логи работы вредоносных образцов являются достаточно информативными с точки зрения ручного анализа, однако для автоматической обработки их следует привести к более компактной и быстрее обрабатываемой форме (как правило, в любых языках программирования операции над строками медленнее операций над числовыми данными). Для анализа цепочек было решено хранить информацию о вызовах как массив из int32 (4 байта на один вызов). Такая форма достаточна для хранения более чем 4 миллионов различных вызовов, а также она поддерживается пакетом numpy ЯП Python. При этом словарь, отображающий фактические имена (и, возможно, параметры) функций в числа хранится отдельно. Это позволяет в дальнейшем возвращать более подробную информацию о найденных совпадениях цепочек. Реализация данного преобразования хранится в lib/pander.py.
\subsection {Алгоритм Смита-Ватермана}
Для сравнения как бинарных, так и текстовых строк (или в нашем случае --- последовательности чисел) классической метрикой является расстояние Левенштейна (также называемое дистанцией редактирования). Между двумя строками дистанцией редактирования будет являться число базовых операций, применяемых к одной строке, чтобы получить другую. К базовым операциям относятся:
\begin {itemize}
	\item Вставка одного символа
	\item Удаление одного символа
	\item Замена одного символа на другой
\end {itemize}
Эта  метрика используется в алгоритме Смита-Ватермана, впервые опубликованном в \cite{LOCALALIGNMENT}. Несмотра на то, что придуман он был для нахождения участков похожих цепочек нуклеотидных последовательностей и относится к генетике, некоторые авторы \cite{BLACKBOOK} относятся к проблеме компьютерных вирусов как к искусственной форме жизни (если точнее, то self-replicating automata, "самовоспроизводящийся автоматический механизм"), поэтому идеи ближе, чем может показаться на первый взгляд.

Существует два основных подхода к сравнению последовательностей: глобальное и локальное выравнивание. Применение глобального выравнивания требует примерно одинаковой длины цепочек, что нельзя гарантировать в случае исследования произвольных образцов. Использование глобального выравнивания можно было бы отнести к поиску практически идентичных копий вредоносных образцов. Алгоритм Смита-Ватермана применяет локальное выравнивание, что ближе к идее нахождения каких-либо распространённых сходных отрезков последовательностей вызовов функций API, потенциально обладающих вредоносным воздействием. Он берёт две последовательности произвольной длины и находит оптимальное выравнивание в любом месте последовательности согласно задаваемой матрице замен, определяющей изменение счёта текущего выравнивания. 

Набор шагов алгоритма для строк $A = a_1 a_2 a_3 ... a_n$ , $B = b_1 b_2 b_3 ... b_m$ длины m и n соответственно заключается в следующем:
\begin {enumerate}
	\item Вычисляем матрицу выравниваний
	
	Двумерная матрица размерностью в ( n X m) инициализируется нулями. В случае использования локального выравнивания первый столбец и первая строка остаются равными 0, чтобы позволить новому выравниванию начаться в любом месте строки без штрафа за вставку первоначальных символов, идущих до выравнивания. Далее матрица продолжает заполняться слева направо и сверху вниз, при этом каждое новое значение выбирается как максимальное из 3х вариантов:
	\begin {itemize}
		\item Цена совмещения очередного символа первой и второй строки $(a_i, b_j)$ плюс цена, стоящая сверху слева по диагонали (предыдущая цена совмещения 2х предыдущих символов строк).
		\item Цена вставки символа первой строки (аналогична совмещению $(a_i, --)$), при этом т.к. не произошло продвижения по символам второй строки, плюс цена сверху.
		\item Цена вставки символа второй строки (аналогична совмещению $(--, b_j)$), при этом т.к. не произошло продвижения по символам первой строки, добавляется цена слева.
	\end {itemize}
	Если получаемое при выборе максимума число отрицательное, вместо него записывается 0, чтобы данная ячейка массива не влияла на нахождение возможных последующих локальных выравниваний.
	После завершения операций матрица выравниваний готова.
	\item Вычисление локального выравнивания

	Задача заключается в обходе матрицы выравниваний по определённым правилам:
	\begin {itemize}
		\item На первом шаге находится максимум массива и запоминаются индексы позиции (i, j), на которой он располагается
		\item Далее с позицией максимума сравниваются ячейки, стоящие выше, слева и по диагонали от неё, чтобы понять, каким из 3х путей этой ячейке было присвоено значение, соответственно производится уменьшение индекса i, j или обоих сразу, реконструируется часть строки выравнивания, после чего операция повторяется
		\item В случае, если значение ячейки, на которую указывают текущие значения индексов (i, j) равно 0, алгоритм завершает работу, возвращая пару реконструированных строк и счёт оптимального выравнивания
	\end {itemize}
	При необходимости алгоритм можно модифицировать для нахождения нескольких пар выравниваний со значениями меньше, чем у оптимального.
\end {enumerate}
Данный алгоритм реализован в lib/seq\_analyzer/local\_alignment.py

