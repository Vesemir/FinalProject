\section {Вступление}
\subsection {Самоизменяющийся исполняемый код}
В современном мире статический анализ исполняемых файлов играет важную роль в обнаружении вирусов. Однако, с момента первого использования этой техники прошёл не один десяток лет, и современные создатели вредоносного ПО способны использовать  различные методы, которые делают статический анализ неэффективным. Некоторые из таких техник заключаются в видоизменении исходного образца тем или иным образом. 
\subsubsection {Полиморфизм}
Полиморфизм заключается в изменении случайным образом кода ПО таким образом, чтобы сохранить изначальный функционал. Одним из простейших путей для реализации является шифрование участков кода, и расшифрование перед исполнением в памяти в определённый момент времени. Однако, это потребовало бы постоянного присутствия кода, реализующего расшифрование, и такой код мог бы являться в дальнейшем сигнатурой для данного вируса. В этом случае, приходится дополнительно использовать вспомогательные механизмы. Пусть у нас есть фрагмент кода, реализующий расшифрование. Как правило, такие участки кода достаточно просты и возможно произвольное изменение регистров, участвующих в таком коде, на другие, а также изменение порядка использования регистров. Фактически, такое действие изменяет последовательности байтов в файле, не меняя смысловой нагрузки программы. Далее, возможно где-либо хранить наборы допустимых замен регистров и во время исполнения программы случайным образом выбирать одну и использовать её. Однако, хранение наборов этих замен требует места, и возможно только для небольших участков кода, т.е. вся остальная часть программы должна быть зашифрована, при этом сам факт наличия зашифрованных участков кода может быть подозрительным (как правило, зашифрование исполняемого файла ведёт к появлению в нём невалидных или редко используемых машинных команд).
\subsubsection {Метаморфизм}
Метаморфизм является следующим логическим шагом после техники полиморфизма. Вместо того, чтобы шифровать всю программу целиком и менять процедуру расшифрования, следует создавать различные версии программы каждый раз, когда она вновь исполняется. Это требует встраивания в тело программы процедуры, которая проводила бы анализ кода программы и изменение её на лету. Причём, такие изменения выполняются не только над самой программой, но и над анализирующей её процедурой. Ключевым моментом здесь является набор изменений, который может реализован данной процедурой:
\lstset{style=masm}

\begin {itemize}
	\item Выбор используемых инструкций и регистров - например, для обнуления регистра eax могут быть использованы каждая из следующих семантически эквивалентных инструкций:
	\begin{lstlisting}
	mov eax, 0
	xor eax, eax
	sub eax, eax
	\end{lstlisting}
	\item Выбор порядка использования инструкций - в некоторых случаях допустимо, если инструкции независимы. Например, иногда современные компиляторы для оптимизации выполнения кода на современных процессорах, использующих конвейеризацию, откладывают выполнение условных переходов для создания возможности параллельного исполнения. Рассмотрим следующий участок кода:
	\begin{lstlisting}
	mov     cl, [edx+eax];
	add     bl, cl
	inc     eax
	cmp     eax, ebp; <-
	mov     [esi], bl;
	jb      short loc_401236; <-
	\end{lstlisting}
	Указанные стрелочкой инструкции логически должны бы следовать друг за другом, однако между ними была добавлена дополнительная инструкция, которая могла бы идти перед сравнением или после выполнения условного перехода. Перемещение её в указанное стрелочкой место, например:
	\begin{lstlisting}
	mov cl, [edx+eax]
	add bl, cl
	inc eax
	mov [esi], bl; <-
	cmp eax, ebp
	jb short loc_401236
	\end{lstlisting}	
незначительным образом сказывается на производительности кода, однако, для вредоносного ПО большее значение имеет происходящее при этом изменение порядка байтов, влиящее на сигнатуру
	\item Обращение условных переходов. Многие современные компиляторы всё ещё используют генерацию условных переходов, соответствующую статическому алгоритму предсказания переходов процессоров семейства Intel NetBurst (Pentium 4 и др.)\cite{INTELMANUAL}. Алгоритм заключается в предсказании условного перехода на инструкции, следовавшие ранее (помогает для циклов) и предсказании отсутствия перехода на инструкции, следующие далее (помогает для конструкций if /else в том случае, когда обычно выполняется блок от if). Аналогично компиляторам, метаморфические вирусы могут обнаруживать блоки таких условных конструкций и переставлять их местами в коде программы, когда такое возможно.

Пример:
	\begin{lstlisting}
	call    lstrcmpA
	jnz     short loc_4012D4
	push    40h; 1
	push    offset aCaption; 1
	push    offset aRightAnswer; 1
	push    [ebp+hWnd]; 1
	call    MessageBoxA; 1
	jmp     short loc_4012E8
loc_4012D4:
	push    10h; 2
	push    offset aCaption; 2
	push    offset aWrongAnswer; 2
	push    [ebp+hWnd]; 2
	call    MessageBoxA; 2
loc_4012E8:
	call    ExitProcess
	\end{lstlisting}
	Замена первоначальной инструкции jnz на jz (переход в случае неравенства на переход в случае равенства) и перестановка местами блоков, помеченных как 1 и 2 не меняет смысловую нагрузку, выполняемую программой, однако позволяет значительно поменять её структуру. Это создаёт значительные трудности как в случае автоматического, так и ручного исследования, если таковых замен произведено значительное количество.
	\item Добавление мусора - заключается в произвольном добавлении инструкций, не влиящих на ход исполнения самой программы. Например, манипуляции с регистром, не используемым в определённом фрагменте кода:
	\begin{lstlisting}
	mov     bl, [edi+ecx]
	lea     esi, [edi+ecx]
	add ebx, eax; <-
	add ebx, esi; <-
	add ebx, ecx; <-
	mov     cl, [edx+eax]
	add     bl, cl
	inc     eax
	xor     ebx, ebx
	\end{lstlisting}
	Указанные стрелочкой инструкции никак не влияют на программу в случае их добавления, поскольку далее ebx всё равно обнуляется.
	\item Изменение порядка хранения функций в модуле - не сказывается на функционале, однако точно так же меняет байтовые сигнатуры, а также может вводить в заблужение лиц, выполняющих ручной анализ.
\end {itemize}

\subsection{Динамический анализ}
Полиморфические вирусы поддаются обнаружению на основе статистического анализа \cite{PAYLOADDETECTION, ANAGRAM}, используя распределение частот редко появляющихся байтов, а также на основе анализа энтропии различных секций файла \cite{ENTROPYANALYSIS}. Метаморфические могут быть распознаны различными техниками семантического анализа графа потока исполнения, построенного на основе обнаруживаемых в исходном файле инструкций вызова функций \cite{METAAWARE}. Однако, для борьбы со всеми вышеупомянутыми методами обнаружения была предложена новая техника маскирования кода вредоносных программ - мимиморфизм\cite{MIMIMORPHISM}. Описание механизма реализации данной техники выходит за рамки данной работы, однако, достаточно сказать, что в результате её работы получаются исполняемые файлы, статистические характеристики, а также граф исполнения которых похожи на обычное ПО. Таким образом, каждая из упомянутых статических техник анализа рано или поздно достигает своих пределов.

В связи с этим, выглядит неизбежным применение динамического анализа исполняемых файлов. В последнее время большое распространение получили ``песочницы'' --- изолированные среды, в рамках которых выполняются исследуемые образцы и происходит сбор изменений, вызванных их деятельностью (Nepenthes, Dionaea). Многие из них основываются на поиске особых ``артефактов'' --- изменений в файловой системе, реестре, директории именованных объектов (BaseNamedObjects, там находятся все мутэксы --- объекты синхронизации, обычно используемые для проверки факта заражённости ПК, чтобы не дать исполняться одновременно многим копиям вируса), списке открытых хэндлов у системных (и не только) процессов и многие другие. Однако, согласно последним прогнозам рынка производителей антивирусных программ\cite{KASPERKSYBULLETIN}, всё большее число вирусов будет стараться отходить от принципа Advanced Persistent Threat (APT). Факт постоянного присутствия (Persistent) после заражения уйдёт в сторону находящихся лишь в памяти вирусов (без файлов), чтобы максимально уменьшить число следов, оставляемых после заражения с целью избежания обнаружения. Факт ``продвинутости'' (Advanced) вирусов, использующих неординарные подходы (в прошлом году прошла волна вируса Carbanak\cite{CARBANAK}, который для реализации механизма скрытия модифицировал прошивку жёстких дисков) и требующих больших затрат на разработку уйдёт в сторону переиспользования уже существующих и появляющихся популярных семейств. Самым естественным для анализа при этом выглядит использование одной из существенных черт любой программы - её взаимодействие с ОС непосредственно в процессе работы через вызовы API функций, причём существенная часть этих вызовов по сути неизбежна. Поэтому, представляется важным нахождение ``отпечатка'' тех или иных фрагментов поведения программы.