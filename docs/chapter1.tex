\section {Пути решения проблемы}
Т.к. Immunity работает лишь с x86, для первых образцов возьмём найденные в сети
исходные коды вирусов и скомпилируем их под соответствующую платформу.
UPDATE: удалось найти 3 сайта, бесплатно предоставляющих уже готовые образцы.

Мониторинг API, пути:
\begin {itemize}
	\item Перехватывающая вызовы API DLL (пр.: Microsoft Detours);
	В том числе : AppInit\_DLL – но лишь при использовании user32.dll.
	\item Перехватывающий вызовы API драйвер (пр.: Process Hacker);
	\item В отладчике, пример реализации дан в \cite{MALWAREBOOK}.
	\item Процедуры, выполняющие уведомления о создании процесса/ потока/ загрузке образа в память (пр.:
 	ProcMon, Process и Thread events).
\end {itemize}

\subsection {Перехватывающая вызовы API DLL}
Рассмотрим подробнее данный способ. Если мы хотим перехватить вызовы N функций в текущем процессе,
 в его адресное пространство после загрузки системных библиотек, содержащих функции, которые необходимо
 отслеживать, мы загружаем нашу cпециально сформированную DLL библиотеку. В своей входной функции,
 выполняющейся во время загрузки, она перезаписывает адреса в таблице импортов процесса на адреса своих
 функций, в которых выполняется логирование вызова, после чего вызывается оригинальная функция. Таким образом, если требуются различные действия для каждой отслеживаемой функции, в нашей DLL будет отдельно
 содержаться функция для каждой из N.
 
 AppInit\_DLL - раздел реестра, в который можно поместить пути до всех DLL, которые будут загружены в адресное
 пространство исполняемых в текущем сеансе процессов. Однако, это сработает только в том случае, когда исполняемый файл содержит импорты из user32.dll, так что полагаться на этот способ не следует.
\subsection {Перехватывающий вызовы API драйвер}
 Концепция аналогична перехватывающей вызовы API DLL, однако адреса в данном случае перезаписываются не в
 таблице импортов исследуемого процесса, а SSDT, что изначально требует найти начало этой таблицы в памяти. Это обычно делается вызовом MmGetSystemRoutineAddress, что возможно только в режиме ядра. Для этого загружается драйвер, выполняющий указанные действия.
\subsection {В отладчике}
Для реализации данного функционала в отладчике достаточно установить точки останова (байт 0xCC) на первый байт каждой библиотечной функции, вызов которой необходимо отслеживать. Дальнейшая необходимая обработка выполняется в самом отладчике.
\subsection {Процедуры уведомления}
В Windows существует набор процедур уведомления, таких, как\\
PsSetCreateProcessNotifyRoutine, PsSetCreateThreadNotifyRoutine и др., которые могут отправлять уведомления в случае возникновения указанных событий драйверу, зарегистрировавшемуся на них (такие, как создание/завершение процесса/потока). Однако, в данном случае полная полученная информация состоит из pid процесса и флага, указывающего факт создания или завершения. Примером реализации такого подхода может служить утилита ProcessMon из набора SysInternals от Марка Руссиновича.
быть вызваны из режима ядра

Пример разбора функционирования одного из современных вирусов, использующего сетевые соединения для
получения команд от управляющего узла дан в \cite{REVERSING}. Для инфицирования там используется следующая последовательность вызовов API функций:
\begin {enumerate}
	\item kernel32.GetModuleFileNameA
	\item kernel32.GetSystemDirectoryA
	\item user32.CharUpperBuffA
	\item crtdll.strstr
	\item crtdll.strcat
	\item kernel32.Sleep
	\item kernel32.CopyFileA
	\item kernel32.ShellExecuteA
	\item kernel32.ExitProcess
\end {enumerate}
После инфицирования вирус заново исполняет себя, но при этом уже из системной директории, удаляя оригинальный
исполняемый файл. При этом для избежания многократного заражения используется объект синхронизации, обладающий уникальным именем - мутэкс.
\begin {enumerate}
	\item kernel32.DeleteFileA
	\item kernel32.CreateMutexA
	\item kernel32.GetLastError
\end {enumerate}
В случае, если он уже присутствует в системе - программа завершает работу. Если всё прошло успешно, для получения управляющих команд начинается главная часть программы - бесконечный цикл, в котором проверяется валидность IP адреса
ПК, а в случае провала - ожидание (wininet.InternetGetConnectedState -> kernel32.Sleep).