\section {Пути решения проблемы}
Т.к. Immunity работает лишь с x86, для первых образцов возьмём найденные в сети
исходные коды вирусов и скомпилируем их под соответствующую платформу.
UPDATE: удалось найти 3 сайта, бесплатно предоставляющих уже готовые образцы.

Мониторинг API, пути:
\begin {itemize}
	\item Перехватывающая вызовы API DLL (пр.: Microsoft Detours);
	В том числе : AppInit\_DLL – но лишь при использовании user32.dll.
	\item Перехватывающий вызовы API драйвер (пр.: Process Hacker);
	\item В отладчике, пример реализации дан в \cite{MALWAREBOOK}.
	\item Процедуры, выполняющие уведомления о создании процесса/ потока/ загрузке образа в память (пр.:
 	ProcMon, Process и Thread events).
\end {itemize}
Пример разбора функционирования одного из современных вирусов, использующего сетевые соединения для
получения команд от управляющего узла дан в \cite{REVERSING}. Для инфицирования там используется следующая последовательность вызовов API функций:
\begin {enumerate}
	\item kernel32.GetModuleFileNameA
	\item kernel32.GetSystemDirectoryA
	\item user32.CharUpperBuffA
	\item crtdll.strstr
	\item crtdll.strcat
	\item kernel32.Sleep
	\item kernel32.CopyFileA
	\item kernel32.ShellExecuteA
	\item kernel32.ExitProcess
\end {enumerate}
После инфицирования вирус заново исполняет себя, но при этом уже из системной директории, удаляя оригинальный
исполняемый файл. При этом для избежания многократного заражения используется объект синхронизации, обладающий уникальным именем - мутэкс.
\begin {enumerate}
	\item kernel32.DeleteFileA
	\item kernel32.CreateMutexA
	\item kernel32.GetLastError
\end {enumerate}
В случае, если он уже присутствует в системе - программа завершает работу. Если всё прошло успешно, для получения управляющих команд начинается главная часть программы - бесконечный цикл, в котором проверяется валидность IP адреса
ПК, а в случае провала - ожидание (wininet.InternetGetConnectedState -> kernel32.Sleep).