\section {Отслеживание происходящих событий}
Для реализации анализатора поведения программ необходимо обеспечить качественный сбор информации о происходящих во время исполнения событиях. В данном разделе будут рассмотрены доступные способы реализации такого анализа и выбран наиболее подходящий из них в рамках данной работы.
\subsection {Пути решения проблемы}
Для решения указанной проблемы нужно найти способ получения происходящих в исполняемых процессах событий. 

Мониторинг API, пути решения:
\begin {itemize}
	\item Перехватывающая вызовы API DLL (пр.: Microsoft Detours);
	В том числе : AppInit\_DLL – но лишь при использовании user32.dll.
	\item Перехватывающий вызовы API драйвер (пр.: Process Hacker);
	\item Отслеживание вызовов в отладчике, пример реализации дан в \cite{MALWAREBOOK}.
	\item Процедуры, выполняющие уведомления о создании процесса/ потока/ загрузке образа в память (пр.:
 	ProcMon, Process и Thread events).
\end {itemize}

\subsubsection {Перехватывающая вызовы API DLL}
Рассмотрим подробнее данный способ. Если мы хотим перехватить вызовы N функций в текущем процессе,
 в его адресное пространство после загрузки системных библиотек, содержащих функции, которые необходимо
 отслеживать, мы загружаем нашу cпециально сформированную DLL библиотеку. В своей входной функции,
 выполняющейся во время загрузки, она перезаписывает адреса в таблице импортов процесса на адреса своих
 функций, в которых выполняется логирование вызова, после чего вызывается оригинальная функция. Таким образом, если требуются различные действия для каждой отслеживаемой функции, в нашей DLL будет отдельно
 содержаться функция для каждой из N.
 
В Windows существует специальный раздел реестра, с помощью которого можно загрузить данную DLL в память. AppInit\_DLL - раздел реестра, в который можно поместить пути до всех DLL, которые будут загружены в адресное пространство исполняемых в текущем сеансе процессов при их инициализации. Однако, это сработает только в том случае, когда исполняемый файл содержит импорты из user32.dll, так что полагаться на этот способ возможно не всегда.
\subsubsection {Перехватывающий вызовы API драйвер}
 Концепция аналогична перехватывающей вызовы API DLL, однако адреса в данном случае перезаписываются не в таблице импортов исследуемого процесса, а SSDT (System Service Descriptor Table), что изначально требует найти начало этой таблицы в памяти. SSDT (Native SSDT) - служебная таблица в Windows, хранящая указатель на таблицу с адресами функций, реализующих те или иные системные вызовы. Когда любой программе требуется реализовать системный вызов, она берёт порядковый номер функции в этой таблице и вызывает инструкцию процессора SYSENTER.  При вызове системная служебная функция KiSystemService забирает этот порядковый номер, смотрит в SSDT и выбирает функцию, индекс которой соответствует переданному числу.
Напрямую из режима пользователя получить адрес нельзя. Это обычно делается вызовом MmGetSystemRoutineAddress, что возможно только в режиме ядра. Для этого загружается драйвер, выполняющий указанные действия.
\subsubsection {В отладчике}
Для реализации данного функционала в отладчике достаточно установить точки останова (байт 0xCC, соответствующий инструкции программного прерывания int 0x3) на старший байт первой инструкции каждой библиотечной функции, вызов которой необходимо отслеживать. При срабатывании прерывания процессор передаёт управление отладчику, если он подключён к процессу, в котором оно произошло. Дальнейшая необходимая обработка выполняется в самом отладчике, после чего он подаёт команду на продолжение исполнения процесса.
\subsubsection {Процедуры уведомления}
В Windows существует набор процедур уведомления, таких, как\\
PsSetCreateProcessNotifyRoutine, PsSetCreateThreadNotifyRoutine и др., которые могут отправлять уведомления в случае возникновения указанных событий (таких, как создание/завершение процесса/потока). Для этого драйвер, который хочет получать уведомления, должен зарегистрироваться на них, вызвав соответствующую функцию и передав указатель на самостоятельно реализумый обработчик . Однако, в данном случае полная полученная информация состоит из pid процесса и флага, указывающего факт создания или завершения. Примером реализации такого подхода может служить утилита ProcessMon из набора SysInternals от Марка Руссиновича.
быть вызваны из режима ядра
\subsection {Выбор реализации}
Одновременно наиболее простой и захватывающей наибольший возможный контекст вызовов реализацией представляется перехват событий через отладчик.

Существует множество бесплатного ПО, реализующего функционал отладчиков. Наиболее примечательным из них для исследования вирусов можно считать Immunity Debugger, изначально проектировавшийся как инструмент для разработки эксплоита, реверсинга исполняемых файлов и анализа вредоносного ПО. Некоторые из его преимуществ по сравнению с обычными отладчиками:
\begin {itemize}
	\item Изначально Immunity разрабатывался на основе старого популярного отладчика - OllyDbg, одним из преимуществ которого была поддержка плагинов. Однако, плагины для OllyDbg представляли собой динамические библиотеки (DLL), требующие компиляции перед использованием. Плагины для Immunity представляют собой скрипты Python, которые можно изменять в любом текстовом редакторе.
	\paragraph {PyCommands}
Immunity Debugger поддерживает реализацию определённой последовательности действий, описанную в скрипте на ЯП Python - PyCommand, которая может быть вызвана через его консоль. Также PyCommand поддерживают хуки - описанные функции, которые будут вызваны в случае возникновения настроенного на них события (обычно, срабатывание прерывания отладки в установленной точке останова).
	\item Immunity содержит в комплекте множество готовых плагинов. Один из них реализует некоторые техники по скрытию факта присутствия отладчика (!hidedebug). Его функционал будет использован в цикле исследования вредоносных образцов. Также, сообществом Python уже созданы реализации многих популярных задач, например, сбор всех функций из таблицы импортов исполняемого файла (mona.py от Corelan GCV). Данный функционал используется для реализации собственного хука, логирующего необходимые данные.
	\item В Immunity реализован механизм автоматического обнаружения упакованных исполняемых файлов. Также есть функционал, позволяющий обнаружить оригинальную точку входа такого исполняемого файла, если используемый упаковщик был одним из распространённых. Дело в том, что в таблице импортов упакованного файла находятся лишь те функции, которые необходимы для процедуры распаковки, а записи о функциях, требуемых для работы оригинального исполняемого файла добавляются в течение распаковки. Если установить отслеживание только первоначально присутствующих функций, большая часть информативности логов будет утеряна.
\end {itemize}
Поскольку Immunity работает только с x86, исследуемые образцы следует предварительно фильтровать по значению платформы, хранящемуся в PE-заголовке исполняемого файла.
\subsection {Примеры последовательностей, используемых вредоносным ПО}
\subsubsection {Backdoor.Hacarmy.D}
Пример разбора функционирования одного из современных вирусов, использующего сетевые соединения для
получения команд от управляющего узла дан в \cite{REVERSING}. Для инфицирования там используется следующая последовательность вызовов API функций:
\begin {enumerate}
	\item kernel32.GetModuleFileNameA
	\item kernel32.GetSystemDirectoryA
	\item user32.CharUpperBuffA
	\item crtdll.strstr
	\item crtdll.strcat
	\item kernel32.Sleep
	\item kernel32.CopyFileA
	\item kernel32.ShellExecuteA
	\item kernel32.ExitProcess
\end {enumerate}
После инфицирования вирус заново исполняет себя, но при этом уже из системной директории, удаляя оригинальный исполняемый файл. При этом для избежания многократного заражения используется объект синхронизации, обладающий уникальным именем - мутэкс.
\begin {enumerate}
	\item kernel32.DeleteFileA
	\item kernel32.CreateMutexA
	\item kernel32.GetLastError
\end {enumerate}
В случае, если он уже присутствует в системе - при вызове CreateMutex происходит ошибка, GetLastError возвращает её код и программа завершает работу. Если всё прошло успешно, для получения управляющих команд начинается главная часть программы - бесконечный цикл, в котором проверяется валидность IP адреса ПК, а в случае провала - ожидание (wininet.InternetGetConnectedState -> kernel32.Sleep), после чего получаются и исполняются соответствующие удалённые команды.
\subsubsection {Техника полого процесса}
Вирусы, использующие для работы собственные процессы, могут быть обнаружены по расположению их файлов образов на жёстком диске, даже если они используют имена как у системных процессов. Однако, существует техника маскирования \cite{MALWAREBOOK}, при которой даже путь расположения будет совпадать с легитимными системными файлами.
Рассмотрим следующую последовательность вызовов:
\begin {enumerate}
	\item CreateProcessA (..., CREATE\_SUSPENDED, ...)
	\item ReadFile
	\item GetModuleHandleA
	\item GetProcAddress
	\item NtUnmapViewOfSection
	\item VirtualAllocEx (..., PAGE\_EXECUTE\_READWRITE, ...)
	\item WriteProcessMemory (в цикле)
	\item SetThreadContext
	\item ResumeThread
\end{enumerate}
По сути, она просто запускает процесс в приостановленном состоянии, удаляет часть страниц его памяти начиная с базового адреса вируса, который должен быть скопирован в чужое адресное пространство (поскольку обычно страницы, хранящие исполняемый не имеют атрибута, разрешающего запись), выделяет для себя новую память и после этого запускает поток, установив указатель инструкций на тело вируса. Для легитимного использования таких действий не представляется возможным найти каких-либо причин, поэтому можно считать такую последовательность свидетельствующей о вредоносности исполняемого файла.